# 從 ReAct 到 Ralph Loop：解決 AI 助手「半途而廢」的持續迭代範式

> **痛點**：為什麼 AI 寫代碼總是「點到為止」？因為模型會主觀認為「完成」就退出，而非達到客觀可驗證的標準。

---

## 🚀 提純後的核心觀察

### 1. 什麼是 Ralph Loop？
這是一種極簡但極其有效的自主迭代機制。核心思想是：**給出任務 + 完成條件 + 外部強制循環**。
當 Agent 嘗試結束會話時，系統通過 **Stop Hook** 攔截動作。如果沒發現預定義的完成承諾（Completion Promise），就重新注入原始提示詞，強迫 Agent 繼續工作直到達標。

### 2. 從「內存記憶」轉向「外部狀態」
傳統 Agent 依賴上下文窗口（記憶），容易發生「上下文腐爛」。Ralph Loop 每一輪都是全新會話，它通過讀取物理文件（`progress.txt`, `prd.json`）和 Git 歷史來同步進度。
- **狀態管理**：從模型 Token 序列轉移到了文件系統。
- **證據驅動**：AI 看到的不是自己的對話紀錄，而是代碼、測試報告和 Git Diff 的「事實」。

### 3. AFK 編程：指揮生產線而非手工操作
- **人在回路 (HITL)**：結對編程，實時引導。
- **離開鍵盤 (AFK)**：定義最終狀態，設置最大迭代次數，讓 Agent 獨自完成 50 輪迭代，你只需要回來審查 PR。

---

## 💡 實踐啟示

1.  **定義可驗證的完成標準**：不要說「幫我重構」，要說「重構直到所有測試通過且 Coverage > 80%」。
2.  **安全機制是前提**：自動化循環必須配合 `max-iterations`（錢包保險）和 Docker 沙箱（系統保險）。
3.  **小步提交的價值**：Ralph 在每一小步成功後 commit，這不僅是回滾方案，更是下一輪迭代的「增量差分」。

---

詳細技術實現與 Playbook 見：
- **[05 Playbook：Ralph Loop 迭代範式與 AFK 指揮](../../stack/methodology/agent-management/05-ralph-loop-iteration-paradigm.mdx)**
