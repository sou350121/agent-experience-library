# Agentic Coding 的本质：文档工程（DocOps）

> 观点：随着自然语言编程成熟，软件工程会部分“翻译”为文档工程。
>
> **你管理的不是源代码，而是源文档；代码是可替换的渲染结果。**

这份方法论来自 `@turingou` 的实战总结：从 0 搭建本地项目时，需求与文档会在与 Codex / Claude Code 的对话中逐渐清晰并持续加深。长期下来，你会发现 agentic coding 更像是在维护一个“需求与状态的网状系统”。

## 1. 核心原则

- **文档先行**：让 Agent 先产出可执行文档（边界、验收、拆分），再写代码。
- **单一真相来源（SSOT）**：每个需求单元只有一个“母文档”，所有实现/修复都回写到它。
- **可追溯**：任何代码改动都能追溯到 story / 里程碑 / 验收条目。
- **可测试**：每个 story 必须能写出可验证的验收标准（哪怕是手工步骤）。

## 2. 推荐的“文档操作系统”文件结构

下面是一套可直接复用的目录约定（你可以放在任何工程仓库里）：

```text
AGENT_CONSTITUTION.md
roadmap.md
stories/
  S-0001-xxx.md
  S-0002-yyy.md
  ...
docs/
  features/
    S-0001-xxx/
      status.md
      decisions.md
      api.md
      ui.md
      bugs.md
      screenshots/
  ...
```

### 2.1 `AGENT_CONSTITUTION.md`（宪法）要写什么？
- **权限与边界**：允许改哪些目录？是否允许联网？是否允许跑迁移脚本？
- **输出规范**：结论/方案/里程碑/PR 的结构（可参考 `tools/agent-dna-workflow`）。
- **安全约束**：密钥处理、数据脱敏、危险命令的审批。

### 2.2 `roadmap.md`（母文档）怎么维护？
- 用版本推进：`v0.1 -> v0.2 -> ...`
- 每次迭代写清：目标、范围、非目标、里程碑、依赖、风险
- 每个里程碑指向若干 `stories/S-xxxx.md`

### 2.3 `stories/S-xxxx.md`（可测试需求单元）建议模板

```markdown
# S-0001-xxx

## 目标

## 验收标准（必须可验证）
- [ ] 

## 范围 / 非目标

## 任务拆分
- [ ] 

## 关联文件（计划/实际）
- 

## 进度日志（每次 Agent session 追加）
- YYYY-MM-DD：...
```

### 2.4 `docs/features/S-xxxx/`（状态账本）怎么用？
- **status.md**：功能状态（进行中/完成/回滚）+ 关键链接（PR/Issue/Story）
- **decisions.md**：关键决策记录（为什么这么做？替代方案是什么？）
- **bugs.md**：bug 修复日志（复现步骤 → 根因 → 修复 → 回归验证）
- **api.md / ui.md**：接口与 UI 变更说明（最好配截图）

> 经验：一个 story 完成后把“事实”沉淀到 docs，未来任何返工都从事实账本出发，而不是从聊天记录出发。

## 3. 为什么这套方法能让你进入心流？

- 你主要在“管理文档系统”，而不是被“代码细节”拖走注意力。
- 需求在对话中逐步清晰时，文档是你的稳定锚点。
- Agent 负责实现与修复，你负责维护故事网的清晰度与一致性。

## 4. 与传统“架构文档”思路的差异

`@turingou` 的一个重要转折是：
- 早期会写一个强约束的 architecture 文档，要求 Agent 按人类技术栈实现。
- 随着软件自然生长（尤其从 0 到 1 阶段），强行约束“万能程序员”意义不大。
- 更有效的是维护**产品故事与需求描述**，让实现细节自然演化（维护存量工程是例外）。

## 5. 与本文库其它内容的连接

- 多 Agent 分工闭环：见 `tools/multi-agent-coding-workflow`
- 结构化产出（结论→分析→方案→里程碑→PR）：见 `tools/agent-dna-workflow`

---
> 💡 总结：在 agentic coding 里，**文档是一等公民，代码是可替换的编译产物**。
