# Agent 执行环境：云端沙箱全权限 vs 本地受控执行（选型与折中）

> 目标：把“体验差异”提纯为可执行的产品/工程选型 checklist。

---

## 1. 两条路线的定义

### 1.1 云端沙箱（Cloud Sandbox, Full Permission in Sandbox）
- Agent 在云端的隔离 Ubuntu/容器/VM 内执行。
- **默认权限更大**（在沙箱内），用户更少被打断。
- **演進：一次性軟體 (Disposable Software)**：軟體不再是資產，而是消耗品。任務結束後，環境、文件系統與本地模型狀態直接銷毀。

### 1.2 本地受控执行（Local Execution, Guarded Permission）
- Agent 在用户本地或受控环境中执行。
- **默认拒绝**，通过白名单/逐步授权获得能力。
- **演進：邊緣推理 (Edge Inference)**：壓力從雲端回流到底層推理引擎（如 vLLM），在本地 Sandbox 實現極速決策。

---

## 2. 体验差异的根因：权限模型

- 云端沙箱：**隔离换放行**（沙箱权限大，但与真实资产隔离）
- 本地受控：**贴近真实换谨慎**（能直接碰私有 repo/凭证/环境，因此必须收紧）

---

## 3. 什么时候选哪条路（决策树）

### 3.1 更适合云端沙箱的场景
- [ ] 一次性任务、可丢弃环境（爬数据、批处理、临时代码生成）
- [ ] **一次性軟體範式**：如臨時錢包轉帳、閱後即焚的數據處理沙箱
- [ ] 追求“丢过去就走人”的异步体验
- [ ] 不需要接触私有凭证/内部网络/本地文件系统

### 3.2 更适合本地受控执行的场景
- [ ] 私有代码库与敏感资产（公司 repo、证书、token）
- [ ] 强依赖本地真实环境（本地依赖、硬件、内网服务）
- [ ] 合规/审计要求高，需要“人类始终在环”

### 3.3 轻量化模型推理引擎（降低本地部署门槛）
当你选择本地受控执行时，往往需要一个稳定的推理引擎作为“本地模型服务层”。除了 vLLM 本体之外，**迷你版 vLLM** 对学习与轻量落地非常友好：
- `https://github.com/GeeeekExplorer/nano-vllm`
- `https://github.com/Wenyueh/MinivLLM`
- `https://github.com/skyzh/tiny-llm`

建议用法：
- **学习/理解**：用小号 vLLM 看清楚调度、KV cache、执行链路的本质。
- **轻量部署/边缘实验**：小模型、单机、实验环境优先小号；生产与多卡吞吐仍以 vLLM 本体为主。
- **配合语义路由**：当系统多模型并存时，引入语义路由层（见 `vLLM 语义路由深度解析`）会显著降低成本与安全风险。

---

## 4. 关键 trade-offs（工程维度）

| 维度 | 云端沙箱 | 本地受控 |
| :--- | :--- | :--- |
| 体验 | 更像异步外包，少打断 | 更像结对编程，常授权 |
| 安全 | 隔离强，但要防数据外流 | 资产近，但权限可控 |
| 上下文 | 默认缺少本地上下文 | 天然贴近真实 repo |
| 成本 | 云资源与运维成本更高 | 成本更低但用户注意力成本更高 |

---

## 5. 折中方案：把“烦人的授权”变少

### 5.1 白名单分层（减少逐次确认）
- [ ] 只对白名单目录授权（例如：repo 根目录）
- [ ] 只允许执行白名单命令（例如：lint/test/build）
- [ ] 明确网络访问策略（默认无网/仅允许特定域名）

### 5.2 幂等安全墙（把高风险动作关进确定逻辑）
- [ ] 把危险操作（写入/删除/发布）封装为脚本/工具（可审计、可回放）
- [ ] Agent 只做“决策与调度”，执行交给可控脚本

### 5.3 异步回传（减少用户陪跑）
- [ ] 长任务拆成阶段性 checkpoint（每阶段给出可验收产物）
- [ ] 允许用户“离开”，但在关键动作（写入/执行/外联）前再确认

---

## 6. 给产品/工程团队的结论

- 如果你卖的是"魔法般的交付体验"，云端沙箱更像默认答案。
- 如果你卖的是"在真实仓库里可靠交付"，本地受控更像默认答案。
- 最优解通常不是二选一，而是：**沙箱做重活，本地做最后一公里；权限用白名单与幂等工具收口。**

---

## 7. 阿里云实践：云端沙箱的完整方案

### 7.1 阿里云服务矩阵对比

| 服务 | 类型 | 执行环境 | 适用场景 | 成本模型 |
|------|------|----------|----------|----------|
| **ECS** (云服务器) | 长期运行 | 完整 VM | Web 应用、Agent 服务 | 0.35 元/小时（2核4G） |
| **函数计算 FC** | Serverless | 临时容器 | 定时任务、事件驱动 | 0.000031 元/调用 |
| **ACK** (容器服务) | 容器编排 | Kubernetes | 多 Agent 并行 | 1.05 元/小时（3节点） |
| **OSS** (对象存储) | 存储 | - | 静态网站、数据湖 | 0.12 元/GB/月 |

### 7.2 三种实战方案对比

#### 方案 A：ECS + Docker（新手推荐）

**场景**：个人开发者，需要一个"随手 Vibe"的云端实验环境

**流程**：
```
[zcode 本地] → [Agent 生成 Docker 镜像]
     ↓
[aliyun ecs CreateInstance] → 创建 ECS
     ↓
[SSH 部署 Docker] → 启动容器
     ↓
[验证] → [aliyun ecs DeleteInstance] 释放资源
```

**优势**：
- ✅ 最接近本地开发体验
- ✅ Docker 确保环境一致性
- ✅ 全流程自动化（Terraform + CLI）
- ✅ 符合 Vibe Coding"短暂性"理念

**成本**：按量付费 0.35 元/小时，实验完成后立即释放

**学习曲线**：⭐⭐（平缓）

---

#### 方案 B：函数计算 + OSS（进阶推荐）

**场景**：定期数据处理、定时任务（如"每周一爬取新闻并分析"）

**流程**：
```
[zcode 本地] → [Agent 生成函数代码]
     ↓
[aliyun fc CreateFunction] → 创建函数
     ↓
[aliyun fc PutTrigger] → 配置定时触发器
     ↓
[自动执行] → 结果存到 OSS
```

**优势**：
- ✅ 真正的"用完即走"
- ✅ 按调用次数计费（几乎免费）
- ✅ 无需管理服务器
- ✅ 自动扩缩容

**成本**：百万次调用免费，个人使用 < 0.1 元/月

**学习曲线**：⭐⭐⭐（适中）

---

#### 方案 C：ACK + 多 Agent（高级）

**场景**：模拟"20 个 Agent 并行工作"，处理大规模数据

**流程**：
```
[zcode 本地] → [Agent 生成 Docker 镜像]
     ↓
[aliyun cs CreateCluster] → 创建 K8s 集群
     ↓
[kubectl apply -f deployment.yaml] → 部署 20 个 Pod
     ↓
[并行执行] → [SLS 日志聚合] → [ARMS 监控]
```

**优势**：
- ✅ 真正的云原生多 Agent 编排
- ✅ 自动容错与负载均衡
- ✅ 可视化监控与日志聚合

**成本**：1.05 元/小时（3节点集群），适合生产环境

**学习曲线**：⭐⭐⭐⭐⭐（陡峭）

---

### 7.3 阿里云 vs 本地执行：决策树

```
[你需要部署 Agent 吗？]
    │
    ├─ 否 → 本地执行（zcode + Claude Code）
    │
    └─ 是 → [需要长期运行？]
             │
             ├─ 是 → [是否需要并行处理？]
             │        │
             │        ├─ 是 → ACK（方案 C）
             │        └─ 否 → ECS + Docker（方案 A）
             │
             └─ 否（一次性任务）→ 函数计算 FC（方案 B）
```

### 7.4 成本优化策略

| 策略 | 适用场景 | 节省比例 |
|------|----------|----------|
| **按量付费** | 学习实验 | 无需包月，按需付费 |
| **使用抢占式实例** | 批处理任务 | 节省 50-80% |
| **函数计算代替 ECS** | 低频任务 | 成本接近 0 |
| **设置自动释放策略** | 防止忘记关机 | 避免意外费用 |
| **使用 OSS 代替 ECS 存储** | 静态资源 | 节省 90% |

### 7.5 幂等安全墙在阿里云的实践

#### ✅ DO（推荐做法）

1. **使用 Terraform 管理基础设施**
   ```hcl
   # 所有云资源即代码
   resource "alicloud_instance" "app" {
     # ...
   }
   ```

2. **通过脚本部署应用**
   ```bash
   # deploy.sh - 可审计、可回滚
   aliyun ecs DescribeInstances
   aliyun ecs DeleteInstance --Force true
   ```

3. **使用 RAM 子账号**
   - 只授予必要权限（最小权限原则）
   - 定期轮换 Access Key
   - 使用 KMS 加密敏感配置

#### ❌ DON'T（避免做法）

1. **直接在 Prompt 中硬编码 Access Key**
   - 风险：泄露到聊天记录或 GitHub
   - 正确做法：使用环境变量或密钥管理服务

2. **手动网页控制台操作**
   - 风险：不可重复、难以审计
   - 正确做法：使用 CLI 或 Terraform

3. **忘记释放资源**
   - 风险：持续计费
   - 正确做法：设置自动释放策略或定时清理脚本

### 7.6 推荐学习路径

1. **第 1-2 周**：本地 Docker 化
   - 阅读：[Docker Mastery for Agents](../tools/docker-mastery-for-agents.mdx)
   - 实践：在本地跑一个 Flask 容器

2. **第 3-4 周**：部署到阿里云 ECS
   - 阅读：[阿里云 + Vibe Coding 实战指南](../tools/aliyun-vibe-coding-practical-guide.mdx)
   - 实践：完成案例 A（Flask + ECS）

3. **第 5-6 周**：Serverless 进阶
   - 实践：完成案例 B（函数计算 + OSS）

4. **第 7-8 周**：多 Agent 编排（可选）
   - 实践：完成案例 C（ACK + Kubernetes）

### 7.7 参考资源

- **完整指南**：[阿里云 + Vibe Coding 实战指南](../tools/aliyun-vibe-coding-practical-guide.mdx)
- **实战案例**：[三个渐进式部署案例](../case-studies/aliyun-vibe-coding-deployment.mdx)
- **启动脚本**：[starter-kits/aliyun-vibe-coding](../../starter-kits/aliyun-vibe-coding/)
- **zcode 集成**：[zcode + 阿里云配置指南](../../starter-kits/aliyun-vibe-coding/zcode-integration-guide.md)

---

## 8. 总结：云端 vs 本地 vs 阿里云

| 维度 | 本地受控 | 云端沙箱（通用） | 阿里云（具体实现） |
|------|----------|-----------------|-------------------|
| **适用场景** | 敏感资产、本地依赖 | 一次性任务、实验 | Web 应用、定时任务、并行处理 |
| **权限模型** | 默认拒绝 | 沙箱内全权限 | RAM 权限控制 |
| **成本** | 低（仅机器成本） | 中等（云资源） | 低至高（按服务类型） |
| **学习曲线** | 平缓 | 适中 | 适中至陡峭 |
| **Vibe Coding 体现** | 强控制、慢验证 | 弱控制、快验证 | **平衡控制与效率** |
| **推荐入门路径** | 开始 → | 熟悉后上云 → | **掌握阿里云三大方案** |

> **最终建议**：
> - 新手：从本地开始，掌握基础后上阿里云
> - 中级：优先使用 ECS + Docker（方案 A）
> - 高级：根据场景选择 FC（低成本）或 ACK（高性能）
> - **核心原则**：所有云操作通过代码（Terraform/CLI），而非手动 Prompt
